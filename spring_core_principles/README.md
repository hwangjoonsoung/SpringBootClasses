# 스프링 핵심 원리 -기본편

## 수업 목표

- 스프링 기본 기능 학습
- 스프링 본질 깊은 이해
- 객체 지향 설계를 고민하는 개발자로 성장

### 객체 지향 설계와 스프링

##### 스프링 프레임워크

- 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트,기타 
- 웹 기술: 스프링 MVC , 스프링 WebFlux
- 데이터 접근 기술: transaction,JDBC ,ORM 지원,XML 지원 
- 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: 코틀린, 그루비

##### 스프링 부트

- 스프링을 편하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
- 스프링과  3rd parth(외부)라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정

##### 스프링의 핵심 개념, 컨셉

- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - 객체 지향언어
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

#### 좋은 객체지향이란?
<img src="img/good_OOP.png">

- 클라이언트의 변경없이 새로운 기능을 변경, 추가,삭제 할 수 있다.
  - 즉 운전자는 모든 자동차를 운전할 수 있다. 라는 개념 
- 역할은 구현의 내부 구조를 알 필요가 없다.

##### 역할과 구현의 분리
- 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해 진다.
- 장점
  - 클라이언트는 대상의 역할만 알면 된다.
  - 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
  - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다..
  - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.

##### 역할과 구현의 분리 (자바언어)
- 자바 언어의 다형성을 활용
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한클래스, 구현 객체
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 객체 설계시 역할을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기 (interface -> class)

##### 객체의 협력이라는 관계부터 생각
- 혼자 있는 객체는 없다.
- 클라이언트: 요청, 서버: 응답
- 수만은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.

##### 다형성의 본질
- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체 사이의 관계에서 시작해야한다.

<b style='color=red'>즉. 인터페이스를 안정적으로 잘 설계하는 것이 중요하다</b>

##### 스프링과 객체지향
- 다형성이 가장 중요하다
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 스프링에서 이야기하는 IoC, DI는 다형성을 활용해서 역활과 구현을 편리하게 다룰 수 있도록 지원한다.

#### 좋은 객체 지향 설계의 5가지 원칙
- SRP (단일 책임의 원칙)
  - 한 클래스는 하나의 책임만 가져야 한다
  - 책임의 범위는 추상적으로 범위는 개발자가 정할 수 있다.
    - 너무 작으면 파일이 많이 생성되고 너무 크면 유지보수가 힘들어짐
  - 중요한 기준은 변경읻. 변경이 있을때 파급 효과가 적으면 단일 책임 원칙을 잘 따르는것
- OCP (개방-폐쇄 원칙)
  - 소프트웨워 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다.
  - 다형성 (interface-class)
  - 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다. 이는 OCP원칙을 위반한다.
  - 이 원칙을 지키려면 객체를 생성하고, 관계를 맺어주는 별도의 조립, 설정자가 필요하다.
- LSP (리스코프 치환 원칙)
  - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
  - 다형성에서 하위 클래스르는 인터페이스 규약을 지켜야 한다. <br>인터페이스의 의도 대로 구현체가 구현되어야 한다.이는 단순히 컴파일 성공 여부를 넘어서는 것을 의미한다.
- ISP (인터페이스 분리 원칙)
  - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    - 자동차 인터페이스 = 운전 인터페이스 + 정비 인터페이스
    - 사용자 인터페이스 = 운전자 인터페이스 + 정비사 인터페이스 
  - 인터페이스를 분리하는 것으로 역활이 조금 더 명확해 지고 대체 가능성이 높아 진다.
- DIP (의존관계 역전 원칙)
  - 구현체 보다는 인터페이스에 의존해야 한다.
    - 의존한다는 의미는 객체가 해당 기능을 전부 다 알고 있다는 의미다.
    - Interface interface = new class(); 는 DIP를 위반하고 있는것이다.

#### 객체 지향 설계와 스프링
- 모든 설계에 역활과 구현을 분리
- 이상적으로는 모든 설계에 인터페이스를 부여하는 것이 좋다.
- 실무 고민
  - 추상화 라는 비용이 생긴다. 코드를 찾아볼때 구현 클래스에 접근하기 위해 interface->class 순으로 접근할 수 밖에 없다.
  - 따라서 확장할 가능성이 없으면, 바로 구현클레스를 사용하는것이 좋다.

### 스프링 핵심 원리 이해1 - 예제 만들기
    public class MemberServiceImpl implements MemberService{
    
        private final MemberRepository memberRepository = new MemoryMemberRepository();
    
        @Override
        public void join(Member member) {
            memberRepository.save(member);
        }
    
        @Override
        public Member findById(Long id) {
            return memberRepository.findById(id);
        }
    }
- 위 코드에서 문제는 MemberServiceImpl는 MemberRepository와 MemorymemberRepository에 의존한다는 것
- 즉 추상화(interface)에도 의존하고 구체화(class)에도 의존 한다는 것이 문제다.(DIP위반)